# Final
Implementing Player Movement Controls and Creating a Wizard Sprite in Game Development
In the realm of 2D game development, creating intuitive player controls and visually distinct character sprites are foundational elements that significantly impact gameplay and user engagement. This essay explores the implementation of player movement controls using arrow keys and the creation of a basic wizard sprite, drawing examples from a p5.js-based Wizard Collision-Avoidance Game. These components are critical for ensuring a responsive and immersive gaming experience, balancing technical precision with creative design.
Player movement is a core mechanic in most interactive games, providing the primary means for players to navigate the game world. In the Wizard Collision-Avoidance Game, movement is implemented using arrow keys, a standard choice for 2D games due to their simplicity and universal familiarity. The implementation leverages the p5.js library, which offers robust input-handling functions to detect key presses and update the player’s position accordingly.
The wizard sprite serves as the visual representation of the player, distinguishing the controllable character from other game elements like obstacles and power-ups. In the Wizard Collision-Avoidance Game, the sprite is a basic shape composed of simple geometric forms, created using p5.js drawing functions. This minimalist approach is effective for prototyping and suits the game’s aesthetic.
The player movement controls and wizard sprite work in tandem to create a cohesive gameplay experience. The arrow key controls allow precise navigation through the game’s levels, where players must avoid moving obstacles and collect power-ups to reach the exit. The wizard sprite provides a visual anchor, making the player’s position and actions immediately clear. 
Implementing collision detection with static obstacles in a game means figuring out when the player bumps into objects that don’t move, like walls or blocks. In simple terms, you check if the player’s position overlaps with an obstacle’s position. Imagine the player and obstacles as shapes (like circles or rectangles) with invisible boundaries. Each time the player moves, the game compares their boundary to the obstacles’ boundaries. If they touch or overlap, the game knows a collision happened and can respond—like stopping the player, reducing lives, or triggering an event.
Adding moving obstacles and obstacle collision detection to a game makes it more exciting by introducing dynamic challenges that the player must avoid. In simple terms, moving obstacles are objects, like sliding blocks or bouncing barriers, that travel across the game screen on their own paths. For example, in a p5.js game, you give each obstacle a position (x, y), size, and speed (dx, dy), updating their location every frame so they move smoothly. Collision detection checks if the player, represented as a shape like a circle, overlaps with these moving obstacles, which are often rectangles. If the player’s position touches an obstacle’s boundaries (by comparing their x, y coordinates and sizes), the game registers a hit, which might reduce lives or reset the level. This setup, as seen in the Wizard Collision-Avoidance Game, keeps players on their toes, requiring quick reflexes to dodge the moving threats.
Completing level design and defining a winning condition in a game involves creating engaging challenges and a clear goal for players to achieve. In a game like the Wizard Collision Avoidance Game, level design means setting up a series of stages, each with a unique arrangement of moving obstacles that players must navigate using arrow keys. These obstacles, such as sliding rectangles, vary in number, size, and speed to increase difficulty across levels, keeping the game exciting. The winning condition is reached when the player safely guides their wizard sprite to a designated goal, represented as a green rectangle (the "exit") at the canvas’s right side. The game checks if the player’s position overlaps with this exit area, and if so, it advances to the next level or declares victory after the final level, rewarding players with points and a sense of accomplishment for dodging all obstacles.
I was really excited to add sound to my Wizard Collision Avoidance Game, thinking it’d make collisions and victories pop with cool effects. I tried using the p5.sound library to play audio for when the player hit obstacles or won, but I kept hitting walls. I couldn’t quite figure it out and while I would have liked the final product more if I could’ve figured it out I am still happy with my final product. 
